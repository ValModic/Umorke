<!DOCTYPE html>
<html lang="sl">
<head>
  <meta charset="UTF-8" />
  <title>Detektivska Mreza</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background-color: #ffffff;
      text-align: center;
    }

    table {
      border-collapse: collapse;
      margin: 0 auto;
    }

    th,
    td {
      width: 40px;
      height: 40px;
      text-align: center;
      border: 1px solid #999;
      font-size: 16px;
      cursor: pointer;
      background-color: white;
      user-select: none;
      transition: box-shadow 0.2s, border 0.2s;
    }

    th {
      background-color: #eee;
      font-weight: bold;
      cursor: default;
    }

    .blank {
      background-color: #eee;
      pointer-events: none;
      border: none;
    }

    .controls {
      margin-top: 20px;
    }

    .mark-button {
      margin: 5px;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      border: 2px solid transparent;
      border-radius: 6px;
    }

    .mark-button.selected {
      border-color: #007bff;
      background-color: #e6f0ff;
    }

    .selected {
      box-shadow: 0 0 0 3px #007bff inset;
    }

    .error {
      border: 2px solid red !important;
    }
  </style>
</head>
<body>
  <h1>üîç Detektivska Mre≈æa 12√ó12</h1>

  <div class="controls">
    <button class="mark-button" id="btn-check" onclick="setMark('‚úì', this)">‚úì</button>
    <button class="mark-button" id="btn-cross" onclick="setMark('‚úó', this)">‚úó</button>
    <button class="mark-button" id="btn-erase" onclick="setMark('', this)">üßΩ</button>
    <button class="mark-button" onclick="clearBlock()">üßº Poƒçisti 4√ó4 blok</button>
    <button class="mark-button" onclick="resetGrid()">üîÅ Resetiraj mre≈æo</button>
  </div>

  <table id="detectiveGrid"></table>

  <script>
    let currentMark = "";
    let lastSelectedCell = null;
    let lastButton = null;
    let selectedCellCoords = null;
    const cellWarnings = new WeakMap();

    function setMark(mark, button) {
      currentMark = mark;
      if (lastButton) lastButton.classList.remove("selected");
      button.classList.add("selected");
      lastButton = button;
    }

    const columnLabels = ["", "S1", "S2", "S3", "S4", "M1", "M2", "M3", "M4", "C1", "C2", "C3", "C4"];
    const rowLabels = ["", "W1", "W2", "W3", "W4", "C1", "C2", "C3", "C4", "M1", "M2", "M3", "M4"];
    const blankCells = new Set();

    blankCells.add("-1,-1");

    for (let i = 4; i < 8; i++) {
      for (let j = 8; j < 12; j++) {
        blankCells.add(`${i},${j}`);
      }
    }
    for (let i = 8; i < 12; i++) {
      for (let j = 4; j < 8; j++) {
        blankCells.add(`${i},${j}`);
      }
    }
    for (let i = 8; i < 12; i++) {
      for (let j = 8; j < 12; j++) {
        blankCells.add(`${i},${j}`);
      }
    }

    const table = document.getElementById("detectiveGrid");
    const cells = [];

    function createCell(r, c) {
      const key = `${r},${c}`;
      const cell = document.createElement("td");

      if (blankCells.has(key)) {
        cell.classList.add("blank");
        return cell;
      }

      const style = [];
      if (r % 4 === 0) style.push("border-top: 2px solid black;");
      if ((r + 1) % 4 === 0) style.push("border-bottom: 2px solid black;");
      if (c % 4 === 0) style.push("border-left: 2px solid black;");
      if ((c + 1) % 4 === 0) style.push("border-right: 2px solid black;");
      cell.setAttribute("style", style.join(" "));

      cell.addEventListener("click", () => {
        if (lastSelectedCell) {
          lastSelectedCell.classList.remove("selected");
          lastSelectedCell.classList.remove("error");
          cellWarnings.set(lastSelectedCell, 0);
        }

        cell.classList.add("selected");
        lastSelectedCell = cell;
        selectedCellCoords = [r, c];

        if (currentMark === "‚úì") {
          const blockRowStart = Math.floor(r / 4) * 4;
          const blockColStart = Math.floor(c / 4) * 4;

          let rowConflict = false;
          for (let col = blockColStart; col < blockColStart + 4; col++) {
            if (col !== c && cells[r][col].textContent === "‚úì") {
              rowConflict = true;
              break;
            }
          }

          let colConflict = false;
          for (let row = blockRowStart; row < blockRowStart + 4; row++) {
            if (row !== r && cells[row][c].textContent === "‚úì") {
              colConflict = true;
              break;
            }
          }

          if (!cellWarnings.has(cell)) cellWarnings.set(cell, 0);

          if (rowConflict || colConflict) {
            let warnCount = cellWarnings.get(cell);
            if (warnCount === 0) {
              cellWarnings.set(cell, 1);
              cell.classList.add("error");
              return; // prvi klik blokira postavitev kljukice
            } else {
              cellWarnings.set(cell, 0);
              cell.classList.remove("error");
            }
          }
        }

        if (currentMark === "") {
          // ƒåe bri≈°e≈° kljukico, pobri≈°i vrstico in stolpec v bloku
          if (cell.textContent === "‚úì") {
            const blockRowStart = Math.floor(r / 4) * 4;
            const blockColStart = Math.floor(c / 4) * 4;
            for (let i = blockRowStart; i < blockRowStart + 4; i++) {
              if (!cells[i][c].classList.contains("blank")) {
                cells[i][c].textContent = "";
                cells[i][c].classList.remove("error");
                cellWarnings.set(cells[i][c], 0);
              }
            }
            for (let j = blockColStart; j < blockColStart + 4; j++) {
              if (!cells[r][j].classList.contains("blank")) {
                cells[r][j].textContent = "";
                cells[r][j].classList.remove("error");
                cellWarnings.set(cells[r][j], 0);
              }
            }
          }
        } else {
          // postavi znak
          cell.textContent = currentMark;

          // ƒåe je kljukica, dodaj kri≈æce v isti vrstici in stolpcu znotraj bloka
          if (currentMark === "‚úì") {
            const blockRow = Math.floor(r / 4) * 4;
            const blockCol = Math.floor(c / 4) * 4;

            for (let i = blockRow; i < blockRow + 4; i++) {
              if (i !== r) {
                const blockCell = cells[i][c];
                if (
                  blockCell &&
                  !blockCell.classList.contains("blank") &&
                  blockCell.textContent !== "‚úì"
                ) {
                  blockCell.textContent = "‚úó";
                }
              }
            }

            for (let j = blockCol; j < blockCol + 4; j++) {
              if (j !== c) {
                const blockCell = cells[r][j];
                if (
                  blockCell &&
                  !blockCell.classList.contains("blank") &&
                  blockCell.textContent !== "‚úì"
                ) {
                  blockCell.textContent = "‚úó";
                }
              }
            }
          }
        }
      });

      return cell;
    }

    // zgradimo tabelo
    const headerRow = document.createElement("tr");
    columnLabels.forEach((label, i) => {
      const th = document.createElement("th");
      if (i === 0) th.classList.add("blank");
      th.textContent = label;
      headerRow.appendChild(th);
    });
    table.appendChild(headerRow);

    for (let r = 0; r < 12; r++) {
      const tr = document.createElement("tr");
      const th = document.createElement("th");
      th.textContent = rowLabels[r + 1];
      tr.appendChild(th);

      const row = [];
      for (let c = 0; c < 12; c++) {
        const cell = createCell(r, c);
        row.push(cell);
        tr.appendChild(cell);
      }
      cells.push(row);
      table.appendChild(tr);
    }

    function clearBlock() {
      if (!selectedCellCoords) return;
      const [r, c] = selectedCellCoords;
      const blockRow = Math.floor(r / 4) * 4;
      const blockCol = Math.floor(c / 4) * 4;
      for (let i = blockRow; i < blockRow + 4; i++) {
        for (let j = blockCol; j < blockCol + 4; j++) {
          const cell = cells[i][j];
          if (cell && !cell.classList.contains("blank")) {
            cell.textContent = "";
            cell.classList.remove("error");
            cellWarnings.set(cell, 0);
          }
        }
      }
    }

    function resetGrid() {
      for (let r = 0; r < 12; r++) {
        for (let c = 0; c < 12; c++) {
          const cell = cells[r][c];
          if (cell && !cell.classList.contains("blank")) {
            cell.textContent = "";
            cell.classList.remove("error");
            cellWarnings.set(cell, 0);
          }
        }
      }
    }
  </script>
</body>
</html>

